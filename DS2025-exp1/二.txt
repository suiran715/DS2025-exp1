class Stack:
    def __init__(self):
        self.items = []
    def push(self, item):
        self.items.append(item)
    def pop(self):
        return self.items.pop() if self.items else None
    def peek(self):
        return self.items[-1] if self.items else None
    def is_empty(self):
        return len(self.items) == 0

def precedence(op):
    precedence_map = {'+': 1, '-': 1, '*': 2, '/': 2}
    return precedence_map.get(op, 0)

def infix_to_postfix(expression):
    tokens = []
    i = 0
    n = len(expression)
    while i < n:
        if expression[i].isdigit():
            j = i
            while j < n and (expression[j].isdigit() or expression[j] == '.'):
                j += 1
            tokens.append(float(expression[i:j]))
            i = j
        elif expression[i] in '+-*/()':
            tokens.append(expression[i])
            i += 1
        elif expression[i] in ' \t':
            i += 1
        else:
            return "式子无效：包含非法字符"
    postfix = []
    op_stack = Stack()
    for token in tokens:
        if isinstance(token, float):
            postfix.append(token)
        elif token == '(':
            op_stack.push(token)
        elif token == ')':
            while op_stack.peek() != '(':
                postfix.append(op_stack.pop())
                if op_stack.is_empty():
                    return "式子无效：括号不匹配"
            op_stack.pop()
        else:
            while not op_stack.is_empty() and op_stack.peek() != '(' and precedence(op_stack.peek()) >= precedence(token):
                postfix.append(op_stack.pop())
            op_stack.push(token)
    while not op_stack.is_empty():
        if op_stack.peek() == '(':
            return "式子无效：括号不匹配"
        postfix.append(op_stack.pop())
    return postfix

def evaluate_postfix(postfix):
    if isinstance(postfix, str):
        return postfix
    stack = Stack()
    for token in postfix:
        if isinstance(token, float):
            stack.push(token)
        else:
            b = stack.pop()
            a = stack.pop()
            if b is None or a is None:
                return "式子无效：运算数不足"
            if token == '+':
                stack.push(a + b)
            elif token == '-':
                stack.push(a - b)
            elif token == '*':
                stack.push(a * b)
            elif token == '/':
                if b == 0:
                    return "式子无效：除数不能为0"
                stack.push(a / b)
    result = stack.pop()
    if not stack.is_empty():
        return "式子无效：运算数过多"
    return result

def calculate(expression):
    postfix = infix_to_postfix(expression)
    return evaluate_postfix(postfix)

# 案例测试
print(calculate("3+4*2"))  # 输出11.0
print(calculate("(3+4)*2"))  # 输出14.0
print(calculate("10/0"))  # 输出式子无效：除数不能为0
print(calculate("3+"))  # 输出式子无效：运算数不足

import math
def calculate_complex(expression):
    if expression.startswith("sin(") and expression.endswith(")"):
        try:
            angle = float(expression[4:-1])
            return math.sin(math.radians(angle))
        except:
            return "式子无效"
    return calculate(expression)

print(calculate_complex("sin(30)"))  # 输出0.5（近似值）